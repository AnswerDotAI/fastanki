[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core API",
    "section": "",
    "text": "user = os.environ['ANKI_USER']\npassw = os.environ['ANKI_PASS']",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#oo-api",
    "href": "core.html#oo-api",
    "title": "Core API",
    "section": "OO API",
    "text": "OO API\n\nsource\n\ndata_path\n\ndef data_path(\n    \n):\n\nReturn the default Anki data folder for this OS.\n\ndata_path()\n\nPath('/Users/racheltho/Library/Application Support/Anki2')\n\n\n\ndata_path().ls()\n\n[Path('/Users/racheltho/Library/Application Support/Anki2/User 1')]\n\n\n\nsource\n\n\nprofiles\n\ndef profiles(\n    \n):\n\nList available Anki profile names.\n\nprofiles()\n\n['User 1']\n\n\n\nsource\n\n\nCollection.open\n\ndef open(\n    profile:NoneType=None\n):\n\nOpen a collection by profile name (creates if needed).\nClass method to open a collection by profile name. Handles backend reuse, creates profile folder if needed, and stores profile_path for auth persistence.\n\ncol = Collection.open()\ncol.profile_path\n\nPath('/Users/racheltho/Library/Application Support/Anki2/User 1')\n\n\n\nsource\n\n\nCollection.load_auth\n\ndef load_auth(\n    \n):\n\nLoad SyncAuth from profile folder, or None if not found.\n\nsource\n\n\nCollection.save_auth\n\ndef save_auth(\n    auth\n):\n\nPersist SyncAuth to profile folder.\nAuth persistence methods: save_auth writes the SyncAuth protobuf to disk, load_auth reads it back. The endpoint is crucial â€” AnkiWeb may redirect you to a different sync server.\n\nsource\n\n\nCollection.sync\n\ndef sync(\n    user:NoneType=None, passw:NoneType=None, media:bool=True, upload:bool=False\n):\n\n\nnote = col.newNote()\nnote.fields[0] = \"Test card front\"\nnote.fields[1] = \"Test card back\"\ncol.addNote(note)\n\n1\n\n\n\nresult = col.sync(user=user, passw=passw)\nresult\n\nrequired: NORMAL_SYNC\n\n\nFull sync implementation: loads saved auth (or logs in), handles endpoint changes, re-authenticates on failure, and manages full upload/download when required.\n# First sync requires credentials\ncol.sync(user=user, passw=passw)\n\n# Subsequent syncs use saved auth\ncol.sync()\n\nsource\n\n\nclose_all\n\ndef close_all(\n    \n):\n\nClose all open Anki backends (nuclear option for crash recovery).\nNuclear option for crash recovery â€” scans all Python objects to find and close any open Rust backends.\n\ncol.models\n\n\nBasic\nBasic (and reversed card)\nBasic (optional reversed card)\nBasic (type in the answer)\nCloze\nImage Occlusion\n\n\n\nMarkdown representations for decks. DeckManager lists deck names, DeckNameId shows name/id, DeckTreeNode shows name with due counts.\n\ncol.sched.deck_due_tree().children[0]\n\nDefault: 11 new, 0 learn, 5 review\n\n\n\ncol.decks\n\n\nDefault\nPrecalculus\n\n\n\nEnables dict-style access: col.models['Basic'] returns the model dict, col.decks['Default'] returns the deck id.\n\nmdl = col.models['Basic']\nmdl['id']\n\n1764652425113\n\n\n\nsource\n\n\nNote.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nnote = col.new_note(mdl)\nnote['Front'], note['Back'] = 'hola', 'hello'\nnote\n\nFront: hola | Back: hello\n\n\n\nsource\n\n\nDeck\n\ndef Deck(\n    col, name\n):\n\nInitialize self. See help(type(self)) for accurate signature.\nWrapper class for a deck with convenient .add(), .due (new/learn/review counts), and .cards (list of card ids).\n\nsource\n\n\nDeckManager.__getitem__\n\ndef __getitem__(\n    name\n):\n\n\nsource\n\n\nCollection.add\n\ndef add(\n    model:NoneType=None, deck:NoneType=None, tags:NoneType=None, fields:VAR_KEYWORD\n):\n\nAdd a note with the given fields.\nConvenient method to add a note with keyword arguments for fields. Defaults to Basic model and Default deck.\n\nnote2 = col.add(Front='hola', Back='hello', tags=['spanish'])\n\n\nsource\n\n\nCollection.add_deck\n\ndef add_deck(\n    name\n):\n\nCreate a deck (use :: for nesting).\nCreates a new deck. Use :: for nested decks (e.g.Â \"Spanish::Vocab\" creates Vocab inside Spanish).\n\ncol.add_deck('Spanish::Vocab')\n\nchanges {\n  deck: true\n  browser_table: true\n  browser_sidebar: true\n  study_queues: true\n  mtime: true\n}\nid: 1772224367444\n\n\n\ndeck = col.decks['Spanish::Vocab']\ndeck.add(Front='adiÃ³s', Back='goodbye')\ndeck.due\n\nVocab: 1 new, 0 learn, 0 review\n\n\n\ncol.remove_notes([note2.id])\n\nâœ“ 1 change(s)\n\n\n\ncol.decks.remove([col.decks.id_for_name('Spanish')])\n\nâœ“ 1 change(s)\n\n\n\ncol.sync()\n\nSync: NO_CHANGES\n\n\n\nsource\n\n\nDeck.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nCard.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nOpChangesWithCount.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nDeckTreeNode.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nDeckNameId.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nDeckManager.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nNotetypeNameId.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\nsource\n\n\nModelManager.__repr__\n\ndef __repr__(\n    \n):\n\nReturn repr(self).\n\ncol.close()",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#functional-api",
    "href": "core.html#functional-api",
    "title": "Core API",
    "section": "Functional API",
    "text": "Functional API\n\nsource\n\nCollection.__exit__\n\ndef __exit__(\n    args:VAR_POSITIONAL\n):\n\n\nsource\n\n\nCollection.__enter__\n\ndef __enter__(\n    \n):\n\nYou can use Collection with Pythonâ€™s with statement. This ensures the collection is always properly closed, even if an error occurs during your operations. No more orphaned database locks or forgotten cleanup calls.\n\nwith Collection.open() as col: note = col.add(Front='hola', Back='hello')\n\n\nsource\n\n\nadd_card\n\ndef add_card(\n    profile:NoneType=None, model:NoneType=None, deck:NoneType=None, tags:NoneType=None, fields:VAR_KEYWORD\n):\n\nAdd a card.\nadd_card lets you create a new card with a single function call. Just pass your field values as keyword arguments. By default it uses the Basic note type and Default deck, but you can specify any model, deck, or tags you like.\n\nnotezh = add_card(Front='ä½ å¥½', Back='hello')\n\n\nsource\n\n\nadd_fb_card\n\ndef add_fb_card(\n    front:str, back:str, profile:str=None, model:str=None, deck:str=None, tags:str=None\n):\n\nAdd a card with a Front and Back and return the id.\n\nsource\n\n\nfind_cards\n\ndef find_cards(\n    query:str, profile:str=None\n):\n\nFind cards matching query string. Returns list of Note objects.\nfind_cards searches your collection and returns a list of Card objects. Pass any Anki search query as the first argument. Common query patterns: - deck:Spanish â€” cards in a specific deck - tag:vocab â€” cards with a tag - front:hello â€” match field content - is:due â€” cards due for review - added:7 â€” added in the last 7 days\nCombine with spaces (AND) or OR: deck:Spanish tag:verb finds Spanish cards tagged â€œverbâ€.\n\ncards = find_cards(\"deck:Default\")\ncards\n\n[Card(1769220553306, nid=1769220312702, due=5, ivl=0, queue=0),\n Card(1771131052669, nid=1771131052669, due=12, ivl=0, queue=0),\n Card(1771131140690, nid=1771131140690, due=13, ivl=0, queue=0),\n Card(1771298205236, nid=1771298205236, due=14, ivl=0, queue=0),\n Card(1771994857427, nid=1771994857425, due=15, ivl=0, queue=0),\n Card(1771994862491, nid=1771994862491, due=18, ivl=0, queue=0),\n Card(1771994864613, nid=1771994864613, due=19, ivl=0, queue=0),\n Card(1771995456598, nid=1771995456598, due=22, ivl=0, queue=0),\n Card(1772223814874, nid=1772223814873, due=23, ivl=0, queue=0),\n Card(1772224020120, nid=1772224020120, due=24, ivl=0, queue=0),\n Card(1772224365000, nid=1772224365000, due=25, ivl=0, queue=0),\n Card(1772224370021, nid=1772224370021, due=28, ivl=0, queue=0),\n Card(1772224372112, nid=1772224372112, due=29, ivl=0, queue=0),\n Card(1772224372153, nid=1772224372153, due=30, ivl=0, queue=0),\n Card(1768961835197, nid=1768961835196, due=55, ivl=4, queue=2),\n Card(1769219943743, nid=1769219943743, due=57, ivl=3, queue=2),\n Card(1769144854211, nid=1769144854210, due=58, ivl=4, queue=2),\n Card(1769220066429, nid=1769220066429, due=59, ivl=5, queue=2),\n Card(1769220312702, nid=1769220312702, due=59, ivl=5, queue=2)]\n\n\n\ncards[0]\n\nCard 1769220553306 (nid: 1769220312702, due: 5, ivl: 0d, queue: 0)\n\n\n\nsource\n\n\nfind_card_ids\n\ndef find_card_ids(\n    query:str, profile:str=None\n):\n\nFind card ids matching query string.\n\nfind_card_ids(\"deck:Default\")\n\n[1769220553306, 1771131052669, 1771131140690, 1771298205236, 1771994857427, 1771994862491, 1771994864613, 1771995456598, 1772223814874, 1772224020120, 1772224365000, 1772224370021, 1772224372112, 1772224372153, 1768961835197, 1769219943743, 1769144854211, 1769220066429, 1769220312702]\n\n\n\nsource\n\n\nfind_notes\n\ndef find_notes(\n    query:str, profile:str=None\n):\n\nFind notes matching query string. Returns list of Note objects.\nfind_notes searches your collection and returns a list of Note objects (rather than Card objects). The query language is the same as find_cards â€” all the same search patterns work. The difference is that find_notes returns one result per note, while find_cards may return multiple cards if a note generates more than one card (e.g., with Cloze or Basic-and-Reversed note types).\n\nnotes = find_notes(\"hello\")\nnotes\n\n[Note(1771994864613, Front='hola', Back='hello', tags=[]),\n Note(1772224372112, Front='hola', Back='hello', tags=[]),\n Note(1772224372153, Front='ä½ å¥½', Back='hello', tags=[])]\n\n\n\nnote = notes[0]\nnote\n\nFront: hola | Back: hello\n\n\n\nsource\n\n\nfind_note_ids\n\ndef find_note_ids(\n    query:str, profile:str=None\n):\n\nFind note ids matching query string.\n\nfind_note_ids(\"hello\")\n\n[1771994864613, 1772224372112, 1772224372153]\n\n\n\nsource\n\n\nupdate_note\n\ndef update_note(\n    note:int, profile:str=None, tags:str=None, add_tags:str=None, fields:VAR_KEYWORD\n):\n\nUpdate an existing noteâ€™s fields and/or tags. Pass a Note object or note ID.\nupdate_note modifies an existing noteâ€™s fields and/or tags. Pass either a Note object or a note ID, along with any fields you want to change as keyword arguments. For tags: - tags=['a','b'] â€” replaces all tags - add_tags='newtag' â€” adds without removing existing tags\n\nupdate_note(note, Back=\"updated answer\", tags='testtag')\n\nFront: hola | Back: updated answer | ğŸ·ï¸ testtag\n\n\n\nupdate_note(note, add_tags='moretagz')\n\nFront: hola | Back: updated answer | ğŸ·ï¸ moretagz, testtag\n\n\n\nsource\n\n\nupdate_fb_note\n\ndef update_fb_note(\n    note_id:int, front:str='', back:str='', profile:str=None, tags:str=None, add_tags:str=None\n):\n\nUpdate an existing noteâ€™s front/back fields and/or tags. Pass a Note object or note ID.\n\nupdate_fb_note(note, front='I am new')\n\nFront: I am new | Back: updated answer | ğŸ·ï¸ moretagz, testtag\n\n\n\nsource\n\n\nget_note\n\ndef get_note(\n    note_id:int, profile:str=None\n):\n\nRetrieve a note by ID.\n\nget_note(note.id)\n\nFront: I am new | Back: updated answer | ğŸ·ï¸ moretagz, testtag\n\n\n\nsource\n\n\ndel_card\n\ndef del_card(\n    notes:int, profile:str=None\n):\n\nDelete card(s) by Note(s) or note id(s).\n\ndel_card([notezh, note])\n\nâœ“ 2 change(s)\n\n\n\nsource\n\n\nsync\n\ndef sync(\n    profile:str=None, user:str=None, passw:str=None, media:bool=True\n):\n\nSync collection, handling open/close automatically.\nsync handles the entire sync lifecycle for you â€” opening the collection, authenticating with AnkiWeb, syncing, and closing up afterwards. The first time you sync, pass your AnkiWeb credentials; theyâ€™ll be saved for future use.\n\no = sync(user=user, passw=passw) # First time\n# sync()  # after that\n\n\nsource\n\n\nanki_tools\n\ndef anki_tools(\n    \n):\n\nAdding cloze cards\n\nsource\n\n\nadd_cloze_card\n\ndef add_cloze_card(\n    text, deck:str='Default', tags:NoneType=None, back_extra:str=''\n):\n\nAdd a cloze deletion card.\n\ntest_cloze = add_cloze_card(\"Minus times {{c1::minus}} is always {{c2::plus}}\", back_extra=\"Proof. Let â€“ğ‘ and â€“ğ‘ represent any two negative numbers. Then (âˆ’ğ‘)(âˆ’ğ‘)=(âˆ’1)(ğ‘)(âˆ’1)(ğ‘)=ğ‘ğ‘(âˆ’1)(âˆ’1)=ğ‘ğ‘.\")\n\n\nget_note(test_cloze)\n\nText: Minus times {{c1::minus}} is always {{c2::plus}} | Back Extra: Proof. Let â€“ğ‘ and â€“ğ‘ represent any two negative numbers. Then (âˆ’ğ‘)(âˆ’ğ‘)=(âˆ’1)(ğ‘)(âˆ’1)(ğ‘)=ğ‘ğ‘(âˆ’1)(âˆ’1)=ğ‘ğ‘.\n\n\n\nupdate_note(test_cloze, add_tags='precalculus')\n\nText: Minus times {{c1::minus}} is always {{c2::plus}} | Back Extra: Proof. Let â€“ğ‘ and â€“ğ‘ represent any two negative numbers. Then (âˆ’ğ‘)(âˆ’ğ‘)=(âˆ’1)(ğ‘)(âˆ’1)(ğ‘)=ğ‘ğ‘(âˆ’1)(âˆ’1)=ğ‘ğ‘. | ğŸ·ï¸ precalculus\n\n\n\nget_note(test_cloze)\n\nText: Minus times {{c1::minus}} is always {{c2::plus}} | Back Extra: Proof. Let â€“ğ‘ and â€“ğ‘ represent any two negative numbers. Then (âˆ’ğ‘)(âˆ’ğ‘)=(âˆ’1)(ğ‘)(âˆ’1)(ğ‘)=ğ‘ğ‘(âˆ’1)(âˆ’1)=ğ‘ğ‘. | ğŸ·ï¸ precalculus\n\n\n\ndel_card(test_cloze)\n\nâœ“ 2 change(s)",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastanki",
    "section": "",
    "text": "Install latest from pypi\n$ pip install fastanki\n\n\n\n\nfrom fastanki import *\nimport os\n\n\nuser = os.environ['ANKI_USER']\npassw = os.environ['ANKI_PASS']",
    "crumbs": [
      "fastanki"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "fastanki",
    "section": "",
    "text": "Install latest from pypi\n$ pip install fastanki\n\n\n\n\nfrom fastanki import *\nimport os\n\n\nuser = os.environ['ANKI_USER']\npassw = os.environ['ANKI_PASS']",
    "crumbs": [
      "fastanki"
    ]
  },
  {
    "objectID": "index.html#functional-api",
    "href": "index.html#functional-api",
    "title": "fastanki",
    "section": "Functional API",
    "text": "Functional API\nadd_card lets you create a new card with a single function call. Just pass your field values as keyword arguments. By default it uses the Basic note type and Default deck, but you can specify any model, deck, or tags you like.\n\nnotezh = add_card(Front='ä½ å¥½', Back='hello')\n\nfind_cards searches your collection and returns a list of Card objects. Pass any Anki search query as the first argument. Common query patterns: - deck:Spanish â€” cards in a specific deck - tag:vocab â€” cards with a tag - front:hello â€” match field content - is:due â€” cards due for review - added:7 â€” added in the last 7 days\nCombine with spaces (AND) or OR: deck:Spanish tag:verb finds Spanish cards tagged â€œverbâ€.\n\ncards = find_cards(\"deck:Default\")\ncards\n\n[Card(1764738198390, nid=1764738198390, due=49, ivl=0, queue=0)]\n\n\n\ncards[0]\n\nCard 1764738198390 (nid: 1764738198390, due: 49, ivl: 0d, queue: 0)\n\n\n\nfind_card_ids(\"deck:Default\")\n\n[1764738198390]\n\n\nfind_notes searches your collection and returns a list of Note objects (rather than Card objects). The query language is the same as find_cards â€” all the same search patterns work. The difference is that find_notes returns one result per note, while find_cards may return multiple cards if a note generates more than one card (e.g., with Cloze or Basic-and-Reversed note types).\n\nnotes = find_notes(\"hello\")\nnotes\n\n[Note(1764738198390, Front='ä½ å¥½', Back='hello', tags=[])]\n\n\n\nnote = notes[0]\nnote\n\nFront: ä½ å¥½ | Back: hello\n\n\n\nfind_note_ids(\"hello\")\n\n[1764738198390]\n\n\nupdate_note modifies an existing noteâ€™s fields and/or tags. Pass either a Note object or a note ID, along with any fields you want to change as keyword arguments. For tags: - tags=['a','b'] â€” replaces all tags - add_tags='newtag' â€” adds without removing existing tags\n\nupdate_note(note, Back=\"updated answer\", tags='testtag')\n\nFront: ä½ å¥½ | Back: updated answer | ğŸ·ï¸ testtag\n\n\n\nupdate_note(note, add_tags='moretagz')\n\nFront: ä½ å¥½ | Back: updated answer | ğŸ·ï¸ testtag, moretagz\n\n\n\nget_note(note.id)\n\nFront: ä½ å¥½ | Back: updated answer | ğŸ·ï¸ moretagz, testtag\n\n\n\ndel_card([notezh, note])\n\nâœ“ 1 change(s)\n\n\nsync handles the entire sync lifecycle for you â€” opening the collection, authenticating with AnkiWeb, syncing, and closing up afterwards. The first time you sync, pass your AnkiWeb credentials; theyâ€™ll be saved for future use.\n\nsync(user=user, passw=passw) # First time\n# sync()  # after that\n\nhost_number: 5",
    "crumbs": [
      "fastanki"
    ]
  },
  {
    "objectID": "index.html#tool-use",
    "href": "index.html#tool-use",
    "title": "fastanki",
    "section": "Tool use",
    "text": "Tool use\n\nanki_tools()\n\n&`[add_fb_card, find_notes, find_note_ids, find_cards, find_card_ids, get_note, del_card, update_fb_note, sync]`\n\n\nHere are the available tools: &[add_fb_card, find_notes, find_note_ids, find_cards, find_card_ids, get_note, del_card, update_fb_note, sync].\nTry to find all my notes. List the IDs and contents you see.\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_016SJDA7Ls3sNefL5JdPpe7e\",\n  \"call\": {\n    \"function\": \"find_notes\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[Note(1764724348705, Front='What is the capital of France?', Back='Paris', tags=[]),\\n Note(176472434&lt;TRUNCATED&gt;\"\n}\n\nHereâ€™s what I found in your collection:\n\n\n\nID\nFront\nBack\nTags\n\n\n\n\n1764724348705\nWhat is the capital of France?\nParis\n(none)\n\n\n1764724348737\nWhat is the capital of France?\nParis\n(none)\n\n\n\nYou have 2 notes, and interestingly they appear to be duplicates â€” both have the same question and answer about the capital of France. Would you like to remove one of them, or is there something else youâ€™d like to do with your collection?\nDelete them.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_011dKzVuBUvYyWEydkYtG1sF\",\n  \"call\": {\n    \"function\": \"del_card\",\n    \"arguments\": {\n      \"notes\": \"1764724348705\"\n    }\n  },\n  \"result\": \"OpChangesWithCount(1)\"\n}\n\n\n{\n  \"id\": \"toolu_016yZBTCXdNVpTydhTg8uTQZ\",\n  \"call\": {\n    \"function\": \"del_card\",\n    \"arguments\": {\n      \"notes\": \"1764724348737\"\n    }\n  },\n  \"result\": \"OpChangesWithCount(1)\"\n}\n\nDone! Both notes have been deleted (2 changes total). Your collection should now be empty. Would you like to add some new cards or do something else?\nTry finding all notes again.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_01JVQAUn4vRZZYxwJikGDAbn\",\n  \"call\": {\n    \"function\": \"find_notes\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[]\"\n}\n\nThe collection is now empty â€” no notes found. Ready for a fresh start! What would you like to add?\nTry adding a note of your choice using add_fb_card and tell me the id.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_01EbRahwqio96vUq7AtMr2uU\",\n  \"call\": {\n    \"function\": \"add_fb_card\",\n    \"arguments\": {\n      \"front\": \"What is the speed of light in a vacuum?\",\n      \"back\": \"Approximately 299,792,458 meters per second (about 3 \\u00d7 10\\u2078 m/s)\"\n    }\n  },\n  \"result\": \"1764727897520\"\n}\n\nDone! I added a physics flashcard about the speed of light. The note ID is 1764727897520.\nWould you like to add more cards, or do something else with this one?\nTry finding all notes again.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_01RpBYttNcGRr15YRP7HBhuy\",\n  \"call\": {\n    \"function\": \"find_notes\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[Note(1764727897520, Front='What is the speed of light in a vacuum?', Back='Approximately 299,792,45&lt;TRUNCATED&gt;\"\n}\n\nThereâ€™s now 1 note in your collection:\n\n\n\n\n\n\n\n\n\nID\nFront\nBack\nTags\n\n\n\n\n1764727897520\nWhat is the speed of light in a vacuum?\nApproximately 299,792,458 meters per second (about 3 Ã— 10â¸ m/s)\n(none)\n\n\n\nWhat would you like to do next?\nOK try get_note with it.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_01Qy2LvuJSdxr421DrcdLq8y\",\n  \"call\": {\n    \"function\": \"get_note\",\n    \"arguments\": {\n      \"note_id\": \"1764727897520\"\n    }\n  },\n  \"result\": \"Note(1764727897520, Front='What is the speed of light in a vacuum?', Back='Approximately 299,792,458&lt;TRUNCATED&gt;\"\n}\n\nIt works! The note comes back as a Note object with:\n\nID: 1764727897520\nFront: What is the speed of light in a vacuum?\nBack: Approximately 299,792,458 meters per second (about 3 Ã— 10â¸ m/s)\nTags: [] (empty)\n\nThe serialization looks clean â€” the __repr__ method you defined earlier is being used. Anything else youâ€™d like to test?\nDelete it now.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_01HE56VzDm5pAydPYQS3pPRg\",\n  \"call\": {\n    \"function\": \"del_card\",\n    \"arguments\": {\n      \"notes\": \"1764727897520\"\n    }\n  },\n  \"result\": \"OpChangesWithCount(1)\"\n}\n\nDone! The note has been deleted. Your collection is empty again.\nOK create, update, and verify a note now.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_018fiP5JTuM8nCVfW46os4Qu\",\n  \"call\": {\n    \"function\": \"add_fb_card\",\n    \"arguments\": {\n      \"front\": \"What is H\\u2082O?\",\n      \"back\": \"Water\"\n    }\n  },\n  \"result\": \"1764731543071\"\n}\n\n\n{\n  \"id\": \"toolu_0153ANMUNw3HQ5AdZzkxu6Mj\",\n  \"call\": {\n    \"function\": \"update_fb_note\",\n    \"arguments\": {\n      \"note_id\": \"1764731543071\",\n      \"back\": \"Water (the chemical formula for water)\",\n      \"add_tags\": \"chemistry\"\n    }\n  },\n  \"result\": \"Note(1764731543071, Front='What is H\\u2082O?', Back='Water (the chemical formula for water)', tags=['chem&lt;TRUNCATED&gt;\"\n}\n\n\n{\n  \"id\": \"toolu_017TbPKpAPK6AJmSswhDDRhA\",\n  \"call\": {\n    \"function\": \"get_note\",\n    \"arguments\": {\n      \"note_id\": \"1764731543071\"\n    }\n  },\n  \"result\": \"Note(1764731543071, Front='What is H\\u2082O?', Back='Water (the chemical formula for water)', tags=['chem&lt;TRUNCATED&gt;\"\n}\n\nAll working! Hereâ€™s what happened:\n\nAdded a card with Front=â€œWhat is Hâ‚‚O?â€ and Back=â€œWaterâ€\nUpdated the back to â€œWater (the chemical formula for water)â€ and added the tag â€œchemistryâ€\nVerified with get_note â€” the changes persisted\n\nThe note ID is 1764731543071. What would you like to test next?\nTry the various find ones that we havenâ€™t done yet.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_016JBXpr9shwyawqdBqf7diZ\",\n  \"call\": {\n    \"function\": \"find_note_ids\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[1764731543071]\"\n}\n\n\n{\n  \"id\": \"toolu_019mDgnKk6ifAinw6ej84LmG\",\n  \"call\": {\n    \"function\": \"find_cards\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[Card(1764731543071, nid=1764731543071, due=47, ivl=0, queue=0)]\"\n}\n\n\n{\n  \"id\": \"toolu_01BBTUkQNTZfCgU2ehbFxDAU\",\n  \"call\": {\n    \"function\": \"find_card_ids\",\n    \"arguments\": {\n      \"query\": \"*\"\n    }\n  },\n  \"result\": \"[1764731543071]\"\n}\n\nAll three work! Hereâ€™s the comparison:\n\n\n\nFunction\nReturns\n\n\n\n\nfind_note_ids(\"*\")\n[1764731543071] â€” just the note ID\n\n\nfind_note_ids gives just IDs (lightweight)\n\n\n\nfind_cards(\"*\")\nCard(1764731543071, nid=1764731543071, due=47, ivl=0, queue=0) â€” full Card object with scheduling info\n\n\nfind_card_ids(\"*\")\n[1764731543071] â€” just the card ID\n\n\n\nInteresting that in this case the note ID and card ID happen to be the same (1764731543071). Thatâ€™s because with a Basic note type, thereâ€™s exactly one card per note.\nThat just leaves sync â€” want me to try that too?\nSure. Delete that note, then sync.\n\n\nğŸ¤–ReplyğŸ¤–\nğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ \n\n{\n  \"id\": \"toolu_013cYoVSkSeF2iUxFoRsFqWb\",\n  \"call\": {\n    \"function\": \"del_card\",\n    \"arguments\": {\n      \"notes\": \"1764731543071\"\n    }\n  },\n  \"result\": \"OpChangesWithCount(1)\"\n}\n\n\n{\n  \"id\": \"toolu_01Gx7MqumvhrTBiq92jdHytr\",\n  \"call\": {\n    \"function\": \"sync\",\n    \"arguments\": {}\n  },\n  \"result\": \"host_number: 5\"\n}\n\nDone! Note deleted and synced to AnkiWeb. All tools are working. ğŸ‰",
    "crumbs": [
      "fastanki"
    ]
  },
  {
    "objectID": "index.html#oo-api",
    "href": "index.html#oo-api",
    "title": "fastanki",
    "section": "OO API",
    "text": "OO API\n\ndata_path()\n\nPath('/app/data/.local/share/Anki2')\n\n\n\nprofiles()\n\n['User 1']\n\n\n\ncol = Collection.open()\ncol.profile_path\n\nPath('/app/data/.local/share/Anki2/User 1')\n\n\n\n# First sync requires credentials\ncol.sync(user=user, passw=passw)\n\n# Subsequent syncs use saved auth\ncol.sync()\n\n\ncol.models\n\n\nBasic\nBasic (and reversed card)\nBasic (optional reversed card)\nBasic (type in the answer)\nCloze\nImage Occlusion\n\n\n\n\ncol.sched.deck_due_tree().children[0]\n\nDefault: 2 new, 0 learn, 0 review\n\n\n\ncol.decks\n\n\nDefault\n\n\n\n\nmdl = col.models['Basic']\nmdl['id']\n\n1764648511131\n\n\n\nnote = col.new_note(mdl)\nnote['Front'], note['Back'] = 'hola', 'hello'\nnote\n\nFront: hola | Back: hello\n\n\n\nnote2 = col.add(Front='hola', Back='hello', tags=['spanish'])\n\n\ncol.add_deck('Spanish::Vocab')\n\nchanges {\n  deck: true\n  browser_table: true\n  browser_sidebar: true\n  study_queues: true\n  mtime: true\n}\nid: 1764727764420\n\n\n\ndeck = col.decks['Spanish::Vocab']\ndeck.add(Front='adiÃ³s', Back='goodbye')\ndeck.due\n\nVocab: 1 new, 0 learn, 0 review\n\n\n\ncol.remove_notes([note2.id])\n\nâœ“ 1 change(s)\n\n\n\ncol.decks.remove([col.decks.id_for_name('Spanish')])\n\nâœ“ 1 change(s)\n\n\n\ncol.sync()\n\nhost_number: 5\n\n\n\ncol.close()",
    "crumbs": [
      "fastanki"
    ]
  }
]